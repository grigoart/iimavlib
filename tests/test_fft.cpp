/*!
 * @file 		test_fft.cpp
 * @author 		Zdenek Travnicek <travnicek@iim.cz>
 * @date 		10. 5. 2016
 * @copyright	Institute of Intermedia, CTU in Prague, 2013
 * 				Distributed under BSD Licence, details in file doc/LICENSE
 *
 */



#include "iimavlib/catch/catch.hpp"
#include "iimavlib/AudioFFT.h"
#include <iostream>
#include <algorithm>
namespace iimavlib {

namespace {
template<typename T1, typename T2, typename T3>
bool compare_vectors_approx(const std::vector<T1>& v1, const std::vector<T2>& v2, T3 precision)
{
	if (v1.size() != v2.size()) return false;
	for (auto i = 0u; i < v1.size(); ++i) {
		if (std::abs(std::abs(v1[i]) - std::abs(v2[i])) > std::abs(precision)) return false;
	}
	return true;
}

std::vector<float> power_seq_8 = {28.0, 10.452503719, 5.65685424949, 4.32956880117, 4.0, 4.32956880117, 5.65685424949, 10.452503719};
std::vector<float> power_seq_16 = {120.0, 41.0066471639, 20.905007438, 14.3996195702, 11.313708499, 9.62151819096, 8.65913760234, 8.15672926567, 8.0, 8.15672926567, 8.65913760234, 9.62151819096, 11.313708499, 14.3996195702, 20.905007438, 41.0066471639};
std::vector<float> power_seq_64 = {2016.0, 652.160519907, 326.473511596, 218.086938782, 164.026588655, 131.697984637, 110.236614287, 94.9865354441, 83.6200297521, 74.8441557397, 67.8833719034, 62.2443672232, 57.5984782807, 53.7183773066, 50.4418959009, 47.6503213441, 45.2548339959, 43.1877338531, 41.396594135, 39.8402638743, 38.4860727638, 37.3078379652, 36.2844182282, 35.3986493462, 34.6365504094, 33.9867258297, 33.4399113561, 32.988627835, 32.6269170627, 32.3501414334, 32.154834316, 32.0385918871, 32.0, 32.0385918871, 32.154834316, 32.3501414334, 32.6269170627, 32.988627835, 33.4399113561, 33.9867258297, 34.6365504094, 35.3986493462, 36.2844182282, 37.3078379652, 38.4860727638, 39.8402638743, 41.396594135, 43.1877338531, 45.2548339959, 47.6503213441, 50.4418959009, 53.7183773066, 57.5984782807, 62.2443672232, 67.8833719034, 74.8441557397, 83.6200297521, 94.9865354441, 110.236614287, 131.697984637, 164.026588655, 218.086938782, 326.473511596, 652.160519907};

std::vector<float> power_plusminus_8_1 = {0.0, 0.0, 0.0, 0.0, 8.0, 0.0, 0.0, 0.0};
std::vector<float> power_plusminus_32_4 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 128.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

std::vector<float> src_rand_8 = {0.339683055206, 0.868532289636, 0.154365680073, 0.776085307182, 0.163187004072, 0.0747516406259, 0.871147313227, 0.917389048349};
std::vector<float> power_rand_8 = {4.16514133837, 0.875772176855, 0.914298261317, 1.27396450408, 1.10837523321, 1.27396450408, 0.914298261317, 0.875772176855};


std::vector<float> src_rand_32 = {0.0440882480453, 0.0239679243213, 0.70715248791, 0.499007331301, 0.0252550300136, 0.760290999907, 0.859398130655, 0.913261939671, 0.68721562312, 0.0655245278591, 0.080799885581, 0.959888815238, 0.708311153383, 0.800008357185, 0.534294803838, 0.413907120842, 0.579746807937, 0.699279920411, 0.926504943521, 0.635493641378, 0.695771237629, 0.207131497324, 0.774791378134, 0.44006864274, 0.559076294327, 0.904859663667, 0.598540233308, 0.232574742491, 0.474735508266, 0.997996672281, 0.518802319315, 0.73304750497};
std::vector<float> power_rand_32 = {18.0607933866, 1.34232128114, 0.526776693276, 1.61363721524, 1.4220527207, 2.48019863483, 2.5629958672, 2.73247338644, 1.28017446702, 0.516956675312, 1.24534559406, 2.76634754277, 0.786019471764, 0.350203945396, 1.47901035681, 1.41959965354, 0.511825216606, 1.41959965354, 1.47901035681, 0.350203945396, 0.786019471764, 2.76634754277, 1.24534559406, 0.516956675312, 1.28017446702, 2.73247338644, 2.5629958672, 2.48019863483, 1.4220527207, 1.61363721524, 0.526776693276, 1.34232128114};

std::vector<float> src_rand_64 = {0.488644202283, 0.834345378202, 0.764244210487, 0.366093457333, 0.686537020039, 0.786600929864, 0.0230536583368, 0.354889005552, 0.627927038279, 0.81027389798, 0.245333790318, 0.291204654056, 0.216277705268, 0.977166168971, 0.31018946883, 0.390935951929, 0.665585537338, 0.0885085770841, 0.43933776347, 0.614966822048, 0.23261965818, 0.983158723299, 0.854539809832, 0.499644414565, 0.843482714987, 0.247830968853, 0.341247543023, 0.0339368495927, 0.879358334893, 0.150129871795, 0.267724634228, 0.88018680234, 0.000211192925751, 0.054778461402, 0.311847831275, 0.431271192361, 0.783572454387, 0.994881355463, 0.759062984081, 0.440697384983, 0.00192847755058, 0.46721064451, 0.796725761909, 0.24478908172, 0.433889244313, 0.475512882953, 0.550906914266, 0.508456056874, 0.0181751771769, 0.5273598944, 0.177418846665, 0.262940572747, 0.364030728797, 0.871226256389, 0.768544704868, 0.11494015341, 0.750947536572, 0.129033438995, 0.611359362378, 0.506679937502, 0.511928788448, 0.422610986711, 0.708255167337, 0.0354756198309};
std::vector<float> power_rand_64 = {30.2326446565, 0.995744352757, 0.432049997066, 2.07328848489, 2.73432502735, 0.94979678102, 1.79350027603, 1.36540379197, 3.41649671693, 3.37660896533, 2.01436002127, 2.65378369257, 1.334890158, 1.57171482633, 2.04308574892, 0.428953427591, 2.87505808094, 3.87630220055, 1.08117558541, 2.78855540995, 2.11422436541, 3.07157093367, 3.27081121003, 1.23150211442, 1.70955424166, 3.63507446722, 2.01376916672, 2.08015963916, 2.21502263301, 1.81711823537, 3.44119547805, 0.7441416577, 0.637171869024, 0.7441416577, 3.44119547805, 1.81711823537, 2.21502263301, 2.08015963916, 2.01376916672, 3.63507446722, 1.70955424166, 1.23150211442, 3.27081121003, 3.07157093367, 2.11422436541, 2.78855540995, 1.08117558541, 3.87630220055, 2.87505808094, 0.428953427591, 2.04308574892, 1.57171482633, 1.334890158, 2.65378369257, 2.01436002127, 3.37660896533, 3.41649671693, 1.36540379197, 1.79350027603, 0.94979678102, 2.73432502735, 2.07328848489, 0.432049997066, 0.995744352757};
}

#define SSTR(x) #x
#define XSTR(x) SSTR(x)

#define TEST_SEQUENCE(_size, _signal, _expected, _precision)\
		auto spectrum = fft.FFT1D(_signal);\
		REQUIRE(spectrum.size() == _size);\
		auto pspectrum = powerSpectrum<float, float>(spectrum);\
		REQUIRE(pspectrum.size() == _size);\
		REQUIRE(compare_vectors_approx(pspectrum, _expected, _precision));

#define TEST_CONSTANT(_number, _size) \
	SECTION(XSTR(_number) " " XSTR(_size) ) { \
			simplearray_t<float> signal(_size,_number);\
			simplearray_t<float> expected_spectrum(_size, 0);\
			expected_spectrum[0]=_size*_number;\
			TEST_SEQUENCE(_size, signal, expected_spectrum, 0.02f * _number)\
		}

#define TEST_SEQ(_size, _result, _prec) \
	SECTION("sequence " XSTR(_size) ) { \
			simplearray_t<float> signal(_size);\
			std::iota(signal.begin(), signal.end(), 0);\
			TEST_SEQUENCE(_size, signal, _result, _prec)\
		}

#define TEST_PLUSMINUS(_size, _number, _result, _prec) \
	SECTION("plusminus " XSTR(_size) ) { \
			simplearray_t<float> signal(_size);\
			bool odd = true;\
			for (auto&s: signal) {\
				s= _number * (odd?1:-1);odd=!odd;\
			}\
			TEST_SEQUENCE(_size, signal, _result, _prec)\
		}

#define TEST_RAW(_size, _src, _result, _prec) \
	SECTION("RAW " XSTR(_size) ) { \
			TEST_SEQUENCE(_size, _src, _result, _prec)\
		}

TEST_CASE("FFT") {
	FFT<float> fft;

	SECTION("constants") {
		TEST_CONSTANT(0, 8)
		TEST_CONSTANT(0, 16)
		TEST_CONSTANT(0, 32)
		TEST_CONSTANT(0, 256)
		TEST_CONSTANT(0, 1024)
		TEST_CONSTANT(0, 8192)
		TEST_CONSTANT(0, 32768)
		TEST_CONSTANT(0, 65536)
		TEST_CONSTANT(1, 8)
		TEST_CONSTANT(2, 8)
		TEST_CONSTANT(1, 16)

		TEST_CONSTANT(256, 256)

		TEST_CONSTANT(-1, 8)
		TEST_CONSTANT(-1024, 1024)
	}
	SECTION("Sequences") {
		TEST_SEQ(8, power_seq_8, 0.1f)
		TEST_SEQ(16, power_seq_16, 0.1f)
		TEST_SEQ(64, power_seq_64, 0.1f)
	}
	SECTION("Plusminus") {
		TEST_PLUSMINUS(8, 1, power_plusminus_8_1, 0.1f)
		TEST_PLUSMINUS(32, 4, power_plusminus_32_4, 0.5f)
	}
	SECTION("Random") {
		TEST_RAW(8, src_rand_8, power_rand_8, 0.1f)
		TEST_RAW(32, src_rand_32, power_rand_32, 0.1f)
		TEST_RAW(64, src_rand_64, power_rand_64, 0.1f)
	}


}

}
